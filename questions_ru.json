[
  {
    "question": "В какой из этих ситуаций интерфейсы лучше, чем абстрактные классы",
      "answer": "Когда вам нужен список возможностей и данных, не зависящих от класса, используйте интерфейс. Когда вам нужно, чтобы определенный тип объекта имел общие характеристики, используйте абстрактный класс",
      "options": [
        "Когда вам нужно определить характеристики типа объекта, используйте интерфейс. Когда вам нужно определить возможности типа объекта, используйте абстрактный класс",
        "Интерфейсы являются наследием старых версий C# и взаимозаменяемы с более новыми абстрактными классами..",
        "Когда вам нужен список возможностей и данных, не зависящих от класса, используйте интерфейс. Когда вам нужно, чтобы определенный тип объекта имел общие характеристики, используйте абстрактный класс",
        "При определении любого сложного объекта следует использовать как интерфейс, так и абстрактный класс."
    ]
  },
  {
      "question": "Какое утверждение верно в отношении делегатов",
      "answer": "Они могут быть соединены вместе",
      "options": [
        "Делегаты не поддерживаются в текущей версии C#",
        "Они не могут быть использованы в качестве обратных вызовов",
        "В качестве параметров делегатам можно передавать только переменные..",
        "Они могут быть соединены между собой цепью."
    ]
  },
  {
      "question": "Какой вариант лучше всего определяет модель асинхронного программирования C#",
      "answer": "на основе задания",
      "options": [
        "на основе задач",
        "на основе обратного вызова",
        "унаследованный обратный вызов",
        "реактивный"
    ]
  },
  {
      "question": "В чем разница между ключевыми словами ref и out",
      "answer": "Переменные, переданные в out, могут быть переданы в функцию без инициализации, в то время как ref указывает, что значение является ссылочным значением, которое может быть изменено внутри вызывающего метода",
      "options": [
        "Переменные, переданные в out, указывают, что параметр является выходным параметром, а ref указывает, что переменная может быть передана в функцию без инициализации",
        "Переменные, переданные в ref, могут быть переданы в функцию без инициализации, в то время как out указывает, что значение является ссылочным значением, которое может быть изменено внутри вызывающего метода",
        "Переменные, переданные в out, могут быть переданы в функцию без инициализации, в то время как ref указывает, что значение является ссылочным значением, которое может быть изменено внутри вызывающего метода",
        "Переменные, переданные в ref, указывают, что параметр является выходным параметром, а out указывает, что переменная может быть передана в функцию без инициализации."
    ]
  },
  {
      "question":" Как можно получить информацию о классе, а также создать его экземпляр во время выполнения",
      "answer": "ответа",
      "options": [
        "отражение",
        "сериализация",
        "абстракция",
        "внедрение зависимостей"
    ]
  },
  {
      "question":" В чем разница между анонимным типом и обычным типом данных",
      "answer": "Анонимные типы не имеют имен типов",
      "options": [
        "Анонимные типы не имеют имен типов",
        "Анонимные типы могут быть только статическими",
        "Анонимные типы можно использовать только в struts",
        "Анонимные типы не работают с LINQ."
    ]
  },
  {
      "question":" Когда в вашем приложении вы бы использовали тип Dictionary, а не Array",
      "answer": " когда вам нужно хранить пары ключ-значение, а не одиночные значения",
      "options": [
        "когда вам нужна неровная структура коллекции",
        "когда вам нужно хранить значения одного типа",
        "когда вам нужно хранить пары ключ-значение, а не одиночные значения",
        "когда вам нужен упорядоченный список с возможностью поиска"
    ]
  },
  {
      "question":" В чем разница между a.Equals(b) и a == b",
      "answer": "Метод .Equals сравнивает содержимое, а == сравнивает идентичность ссылок..",
      "options": [
        "Метод .Equals сравнивает идентичность ссылок, а метод == сравнивает содержимое..",
        "Метод .Equals сравнивает примитивные значения, в то время как == сравнивает все значения",
        "Метод .Equals сравнивает содержимое, а == сравнивает идентичность ссылок..",
        "Метод .Equals сравнивает ссылочные типы, в то время как == сравнивает примитивные типы значений"
    ]
  },
  {
      "question":" Какой вариант лучше всего описывает ситуацию тупика",
      "answer": " когда одновременные инструкции ожидают завершения друг друга перед выполнением",
      "options": [
        "когда одновременные инструкции ожидают завершения друг друга перед выполнением",
        "когда вы пытаетесь одновременно инстанцировать два объекта в одном классе или структуре",
        "когда вы пытаетесь выполнить действие после регистрации пользовательского события",
        "когда вы пытаетесь выполнить серию событий одновременно на нескольких потоках"
    ]
  },
  {
      "question":" Как работает ключевое слово async",
      "answer": "Он позволяет использовать ключевое слово await в методе",
      "options": [
        "Он позволяет получить доступ к асинхронным методам в API C#",
        "Он позволяет объединять потоки и синхронные процессы в статических классах..",
        "Он позволяет использовать ключевое слово await в методе",
        "Он позволяет получить доступ к синхронным методам в API C#"
    ]
  },
  {
      "question":" Что такое объект в C#",
      "answer": "экземпляр класса или структуры, включающий поля, свойства и или методы",
      "options": [
        "класс или структура, включая его переменные и функции",
        "примитивный тип данных, который может быть создан только во время компиляции",
        "тип значения, который может быть использован только с абстрактным классом",
        "экземпляр класса или структуры, включающий поля, свойства и или методы"
    ]
  },
  {
      "question":" Что будет возвращено при выполнении этого метода public void userInput(string charParameters) {}",
      "answer": "ничего",
      "options": [
        "ничего",
        "булево значение",
        "строковая переменная",
        "целое число"
    ]
  },
  {
      "question":" Лямбда-выражения часто используются в тандеме с каким из следующих выражений",
      "answer": "на вопросы LINQ",
      "options": [
        "Пространства имен",
        "LINQ",
        "Тип алиасинга",
        "Сборки"
    ]
  },
  {
      "question":" Как сделать метод в абстрактном классе переопределяемым",
      "answer": "Сделайте его виртуальным",
      "options": [
        "Сделайте его публичным",
        "Сделайте его статичным",
        "Сделайте его приватным",
        "Сделайте его виртуальным"
    ]
  },
  {
      "question":" Как бы вы написали код для целочисленного свойства Age с геттером и сеттером",
      "answer": "public int Age { get; set;}",
      "options": [
        "public int Age (get, set );",
        "public int Age get set;",
        "public int Age { get - set}",
        "public int Age { get; set;}"
    ]
  },
  {
      "question":" Что такое абстрактный класс",
      "answer": "класс, который может быть использован только как базовый класс",
      "options": [
        "класс, который может быть использован только как базовый класс",
        "класс, который обозначается ключевым словом virtual",
        "то, что обозначается ключевым словом abstract и используется в системе; если вы хотите, чтобы любая программа создавала объект класса, вы используете абстрактный класс",
        "класс, обозначаемый ключевым словом class (его может видеть и использовать любой другой класс в системе - поэтому по умолчанию он является публичным)"
    ]
  },
  {
      "question":" При использовании пула потоков что происходит с данным потоком после того, как он завершает свою задачу",
      "answer": "Нить возвращается в пул для повторного использования..",
      "options": [
        "Нить возвращается в пул для повторного использования..",
        "Поток становится неактивным в фоновом режиме и ожидает сборки мусора",
        "Нить работает в цикле до следующего задания..",
        "Поток уничтожается, а память освобождается."
    ]
  },
  {
      "question":" Какой выбор представляет класс, который наследует поведение от базового класса",
      "answer": "производному классу",
      "options": [
        "второй базовый класс",
        "пересмотренный класс",
        "производный класс",
        "родительский класс"
    ]
  },
  {
      "question":"Какова основная цель LINQ",
      "answer": "на запрос и преобразование данных",
      "options": [
        "для запроса и преобразования данных",
        "для удаления дубликатов данных",
        "для связывания пространств имен и сборок",
        "для соединения узлов"
    ]
  },
  {
      "question":"Каков правильный синтаксис для нового общего списка строк с именем contacts",
      "answer": "var contacts = new List();",
      "options": [
        "public Список контактов = новый список();",
        "public List(string names) contacts = new List(string names)();",
        "var contacts = new List();",
        "var contacts = new List(string);"
    ]
  }
]